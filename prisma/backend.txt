router.use("/leads/installation/under-installation", underInstallationStageRoutes);

underInstallationStageRoutes.post(
  "/issue-log/create",
  controller.createInstallationIssueLog
);

underInstallationStageRoutes.get(
  "/issue-log/vendor/:vendor_id/lead/:lead_id",
  controller.getInstallationIssueLogs
);

underInstallationStageRoutes.get(
  "/issue-log/:id",
  controller.getInstallationIssueLogById
);

underInstallationStageRoutes.put(
  "/issue-log/:id/update",
  controller.updateInstallationIssueLog
);

 async createInstallationIssueLog(req: Request, res: Response) {
    try {
      const {
        vendor_id,
        lead_id,
        account_id,
        issue_type_ids,
        issue_description,
        issue_impact,
        responsible_team_ids,
        created_by,
      } = req.body;

      // Mandatory checks
      if (
        !vendor_id ||
        !lead_id ||
        !account_id ||
        !issue_type_ids?.length ||
        !issue_description ||
        !issue_impact ||
        !responsible_team_ids?.length ||
        !created_by
      ) {
        return res.status(400).json({
          success: false,
          message: "All fields are mandatory",
        });
      }

      const data = await UnderInstallationStageService.addInstallationIssueLog({
        vendor_id,
        lead_id,
        account_id,
        issue_type_ids,
        issue_description,
        issue_impact,
        responsible_team_ids,
        created_by,
      });

      return res.status(201).json({ success: true, data });
    } catch (error: any) {
      console.error("Error creating Installation Issue Log:", error.message);
      return res.status(500).json({ success: false, error: error.message });
    }
  }

  async getInstallationIssueLogs(req: Request, res: Response) {
    try {
      const vendor_id = parseInt(req.params.vendor_id);
      const lead_id = parseInt(req.params.lead_id);

      if (!vendor_id || !lead_id) {
        return res.status(400).json({
          success: false,
          message: "vendor_id and lead_id are required",
        });
      }

      const data = await UnderInstallationStageService.getInstallationIssueLogs(
        vendor_id,
        lead_id
      );

      return res.status(200).json({ success: true, data });
    } catch (err: any) {
      console.error("Error fetching issue logs:", err.message);
      return res.status(500).json({ success: false, error: err.message });
    }
  }

  async getInstallationIssueLogById(req: Request, res: Response) {
    try {
      const id = parseInt(req.params.id);

      if (!id) {
        return res.status(400).json({
          success: false,
          message: "id is required",
        });
      }

      const data =
        await UnderInstallationStageService.getInstallationIssueLogById(id);

      if (!data) {
        return res.status(404).json({
          success: false,
          message: "Issue log not found",
        });
      }

      return res.status(200).json({ success: true, data });
    } catch (err: any) {
      console.error("Error fetching issue log:", err.message);
      return res.status(500).json({ success: false, error: err.message });
    }
  }

  async updateInstallationIssueLog(req: Request, res: Response) {
    try {
      const id = parseInt(req.params.id);

      if (!id)
        return res.status(400).json({
          success: false,
          message: "id is required",
        });

      const {
        issue_type_ids,
        issue_description,
        issue_impact,
        responsible_team_ids,
        updated_by,
      } = req.body;

      // Ensure at least one field is sent
      if (
        !issue_type_ids &&
        !issue_description &&
        !issue_impact &&
        !responsible_team_ids
      ) {
        return res.status(400).json({
          success: false,
          message: "At least one field must be updated",
        });
      }

      if (!updated_by) {
        return res.status(400).json({
          success: false,
          message: "updated_by is required",
        });
      }

      const data =
        await UnderInstallationStageService.updateInstallationIssueLog(id, {
          issue_type_ids,
          issue_description,
          issue_impact,
          responsible_team_ids,
          updated_by,
        });

      return res.status(200).json({ success: true, data });
    } catch (error: any) {
      console.error("Error updating issue log:", error.message);
      return res.status(500).json({ success: false, error: error.message });
    }
  }

  static async addInstallationIssueLog(payload: InstallIssueLogPayload) {
    return prisma.$transaction(async (tx) => {
      const {
        vendor_id,
        lead_id,
        account_id,
        issue_type_ids,
        issue_description,
        issue_impact,
        responsible_team_ids,
        created_by,
      } = payload;

      // 1️⃣ Create main issue log master
      const issueLog = await tx.installationIssueLogMaster.create({
        data: {
          vendor_id,
          lead_id,
          account_id,
          issue_description,
          issue_impact,
          created_by,
        },
      });

      const issueLogId = issueLog.id;

      // 2️⃣ Create Issue Type Mappings
      const typeData = issue_type_ids.map((type_id) => ({
        issue_log_id: issueLogId,
        type_id,
      }));

      await tx.issueLogTypeMapping.createMany({
        data: typeData,
        skipDuplicates: true,
      });

      // 3️⃣ Create Responsible Teams Mappings
      const teamData = responsible_team_ids.map((team_id) => ({
        issue_log_id: issueLogId,
        team_id,
      }));

      await tx.issueLogResponsibleTeamMapping.createMany({
        data: teamData,
        skipDuplicates: true,
      });

      // 4️⃣ Return full issue log with relations
      return tx.installationIssueLogMaster.findUnique({
        where: { id: issueLogId },
        include: {
          issueTypes: { include: { type: true } },
          responsibleTeams: { include: { team: true } },
        },
      });
    });
  }

  static async getInstallationIssueLogs(vendor_id: number, lead_id: number) {
    return prisma.installationIssueLogMaster.findMany({
      where: {
        vendor_id,
        lead_id,
      },
      orderBy: { created_at: "desc" },

      include: {
        createdBy: {
          select: { id: true, user_name: true },
        },
        issueTypes: {
          include: { type: true },
        },
        responsibleTeams: {
          include: { team: true },
        },
      },
    });
  }

  static async getInstallationIssueLogById(id: number) {
    return prisma.installationIssueLogMaster.findUnique({
      where: { id },

      include: {
        createdBy: {
          select: { id: true, user_name: true },
        },
        issueTypes: {
          include: { type: true },
        },
        responsibleTeams: {
          include: { team: true },
        },
        lead: {
          select: {
            id: true,
            lead_code: true,
            firstname: true,
            lastname: true,
          },
        },
        account: {
          select: {
            id: true,
            name: true,
            contact_no: true,
          },
        },
      },
    });
  }

  static async updateInstallationIssueLog(
    id: number,
    payload: {
      issue_type_ids?: number[];
      issue_description?: string;
      issue_impact?: string;
      responsible_team_ids?: number[];
      updated_by: number;
    }
  ) {
    return prisma.$transaction(async (tx) => {
      const existing = await tx.installationIssueLogMaster.findUnique({
        where: { id },
      });

      if (!existing) throw new Error("Issue log not found");

      const {
        issue_type_ids,
        issue_description,
        issue_impact,
        responsible_team_ids,
      } = payload;

      // 1️⃣ Update issue description / impact if provided
      await tx.installationIssueLogMaster.update({
        where: { id },
        data: {
          issue_description: issue_description ?? existing.issue_description,
          issue_impact: issue_impact ?? existing.issue_impact,
        },
      });

      // 2️⃣ Update Issue Types
      if (issue_type_ids) {
        await tx.issueLogTypeMapping.deleteMany({
          where: { issue_log_id: id },
        });

        await tx.issueLogTypeMapping.createMany({
          data: issue_type_ids.map((type_id) => ({
            issue_log_id: id,
            type_id,
          })),
        });
      }

      // 3️⃣ Update Responsible Teams
      if (responsible_team_ids) {
        await tx.issueLogResponsibleTeamMapping.deleteMany({
          where: { issue_log_id: id },
        });

        await tx.issueLogResponsibleTeamMapping.createMany({
          data: responsible_team_ids.map((team_id) => ({
            issue_log_id: id,
            team_id,
          })),
        });
      }

      // 4️⃣ Return updated full record
      return tx.installationIssueLogMaster.findUnique({
        where: { id },
        include: {
          issueTypes: { include: { type: true } },
          responsibleTeams: { include: { team: true } },
          createdBy: { select: { id: true, user_name: true } },
        },
      });
    });
  }

  to get issuetype this issue type

  router.use("/issue-logs", issueLogRoutes);

  issueLogRoutes.get("/issue-type/vendor/:vendor_id", getIssueTypes);

  // GET All Issue Types by Vendor
export const getIssueTypes = async (req: Request, res: Response) => {
  console.log("[CONTROLLER] getIssueTypes called", { params: req.params });

  try {
    const vendor_id = parseInt(req.params.vendor_id);

    if (!vendor_id) {
      return res.status(400).json({ success: false, error: "vendor_id is required" });
    }

    const list = await fetchIssueTypes(vendor_id);
    return res.status(200).json({ success: true, data: list });
  } catch (error: any) {
    console.error("[CONTROLLER] Error fetching issue types", error.message);
    return res.status(500).json({ success: false, error: error.message });
  }
};

export const fetchIssueTypes = async (vendor_id: number) => {
  console.log("[SERVICE] fetchIssueTypes", { vendor_id });

  return prisma.issueLogTypeMaster.findMany({
    where: { vendor_id },
    orderBy: { created_at: "desc" },
  });
};