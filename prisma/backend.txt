router.use("/leads/installation/under-installation", underInstallationStageRoutes);

underInstallationStageRoutes.post(
  "/usable-handover/update",
  upload.array("files"),   // multer — multiple files allowed
  controller.updateUsableHandover
);

// GET usable handover
underInstallationStageRoutes.get(
  "/:vendor_id/:lead_id",
  controller.getUsableHandover
);

// PUT update remarks
underInstallationStageRoutes.put(
  "/update-remarks",
  controller.updateRemarks
);

 async updateUsableHandover(req: Request, res: Response) {
    try {
      const {
        vendor_id,
        lead_id,
        account_id,
        created_by,
        pending_work_details,
      } = req.body;

      if (!vendor_id || !lead_id || !account_id || !created_by) {
        return res.status(400).json({
          success: false,
          message: "vendor_id, lead_id, account_id, created_by are required",
        });
      }

      const files = (req.files as Express.Multer.File[]) || [];

      const data = await UnderInstallationStageService.updateUsableHandover({
        vendor_id: Number(vendor_id),
        lead_id: Number(lead_id),
        account_id: Number(account_id),
        created_by: Number(created_by),
        pending_work_details,
        files,
      });

      return res.status(200).json({
        success: true,
        message: "Usable Handover updated successfully",
        data,
      });
    } catch (error: any) {
      console.error("Error in updateUsableHandover:", error.message);
      return res.status(500).json({
        success: false,
        error: error.message,
      });
    }
  }

  async getUsableHandover(req: Request, res: Response) {
    try {
      const { vendor_id, lead_id } = req.params;

      const data = await UnderInstallationStageService.getUsableHandover(
        Number(vendor_id),
        Number(lead_id)
      );

      return res.status(200).json({ success: true, data });
    } catch (error: any) {
      console.error("Error fetching usable handover:", error.message);
      return res.status(500).json({ success: false, error: error.message });
    }
  }

  async updateRemarks(req: Request, res: Response) {
    try {
      const { vendor_id, lead_id, pending_work_details } = req.body;

      if (!vendor_id || !lead_id) {
        return res.status(400).json({
          success: false,
          message: "vendor_id and lead_id are required",
        });
      }

      const data = await UnderInstallationStageService.updateRemarks(
        Number(vendor_id),
        Number(lead_id),
        pending_work_details
      );

      return res.status(200).json({
        success: true,
        message: "Remarks updated successfully",
        data,
      });
    } catch (error: any) {
      console.error("Error updating remarks:", error.message);
      return res.status(500).json({ success: false, error: error.message });
    }
  }

   static async updateUsableHandover(payload: UsableHandoverPayload) {
    const {
      vendor_id,
      lead_id,
      account_id,
      created_by,
      pending_work_details,
      files,
    } = payload;

    // -----------------------------------------
    // 1️⃣ Update Pending Work Details
    // -----------------------------------------
    await prisma.leadMaster.update({
      where: { id: lead_id },
      data: {
        usable_handover_pending_work_details: pending_work_details,
      },
    });

    // -----------------------------------------
    // 2️⃣ Fetch document types
    // -----------------------------------------
    const finalSitePhotoType = await prisma.documentTypeMaster.findFirst({
      where: { vendor_id, tag: "Type 25" },
    });

    if (!finalSitePhotoType)
      throw new Error("Document type (Type 25) not found for this vendor");

    const handoverDocType = await prisma.documentTypeMaster.findFirst({
      where: { vendor_id, tag: "Type 26" },
    });

    if (!handoverDocType)
      throw new Error("Document type (Type 26) not found for this vendor");

    // -----------------------------------------
    // 3️⃣ Upload Documents
    // -----------------------------------------
    const uploadedDocs = [];

    for (const file of files) {
      const originalName = file.originalname;
      const buffer = file.buffer;

      let sysName = "";
      let docTypeId = 0;

      const isImage = file.mimetype.startsWith("image/");

      if (isImage) {
        sysName =
          await uploadToWasabiUnderInstallationUsableHandoverFinalSitePhotos(
            buffer,
            vendor_id,
            lead_id,
            originalName
          );

        docTypeId = finalSitePhotoType.id;
      } else {
        sysName =
          await uploadToWasabiUnderInstallationUsableHandoverDocuments(
            buffer,
            vendor_id,
            lead_id,
            originalName
          );

        docTypeId = handoverDocType.id;
      }

      const savedDoc = await prisma.leadDocuments.create({
        data: {
          vendor_id,
          account_id,
          lead_id,
          created_by,
          doc_type_id: docTypeId,
          doc_og_name: originalName,
          doc_sys_name: sysName,
        },
      });

      uploadedDocs.push(savedDoc);
    }

    return {
      pending_work_details,
      uploaded_docs: uploadedDocs,
    };
  }

  static async getUsableHandover(vendor_id: number, lead_id: number) {
    // 1️⃣ Fetch pending work details from LeadMaster
    const lead = await prisma.leadMaster.findUnique({
      where: { id: lead_id },
      select: { usable_handover_pending_work_details: true },
    });

    if (!lead) throw new Error("Lead not found");

    // 2️⃣ Fetch final site photo type
    const finalSitePhotoType = await prisma.documentTypeMaster.findFirst({
      where: { vendor_id, tag: "Type 25" },
    });

    // 3️⃣ Fetch handover document type
    const handoverDocType = await prisma.documentTypeMaster.findFirst({
      where: { vendor_id, tag: "Type 26" },
    });

    const finalSitePhotos = finalSitePhotoType
      ? await prisma.leadDocuments.findMany({
          where: {
            vendor_id,
            lead_id,
            doc_type_id: finalSitePhotoType.id,
          },
        })
      : [];

    const handoverDocuments = handoverDocType
      ? await prisma.leadDocuments.findMany({
          where: {
            vendor_id,
            lead_id,
            doc_type_id: handoverDocType.id,
          },
        })
      : [];

    // 4️⃣ Attach Signed URLs
    const finalSitePhotosWithUrl = await Promise.all(
      finalSitePhotos.map(async (doc) => ({
        ...doc,
        signedUrl: await generateSignedUrl(doc.doc_sys_name),
      }))
    );

    const handoverDocumentsWithUrl = await Promise.all(
      handoverDocuments.map(async (doc) => ({
        ...doc,
        signedUrl: await generateSignedUrl(doc.doc_sys_name, 3600, "attachment"),
      }))
    );

    return {
      pending_work_details: lead.usable_handover_pending_work_details,
      final_site_photos: finalSitePhotosWithUrl,
      handover_documents: handoverDocumentsWithUrl,
    };
  }

  // ----------------------------------------
  // PUT API — Update Remarks Only
  // ----------------------------------------
  static async updateRemarks(
    vendor_id: number,
    lead_id: number,
    pending_work_details: string
  ) {
    const updatedLead = await prisma.leadMaster.update({
      where: { id: lead_id },
      data: {
        usable_handover_pending_work_details: pending_work_details,
      },
    });

    return updatedLead;
  }