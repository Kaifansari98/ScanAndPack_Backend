router.use("/leads/installation/under-installation", underInstallationStageRoutes);

/**
 * POST â†’ Create Miscellaneous Issue with documents
 */
underInstallationStageRoutes.post(
  "/vendorId/:vendorId/leadId/:leadId/create",
  upload.array("files", 10), // max 10 docs
  controller.createMiscellaneousEntry
);

underInstallationStageRoutes.get(
  "/vendorId/:vendorId/leadId/:leadId/get-all",
  controller.getAllMiscellaneousEntries
);

  async createMiscellaneousEntry(req: Request, res: Response) {
    try {
      const vendorId = Number(req.params.vendorId);
      const leadId = Number(req.params.leadId);

      const {
        account_id,
        misc_type_id,
        problem_description,
        reorder_material_details,
        quantity,
        cost,
        supervisor_remark,
        expected_ready_date,
        is_resolved,
        teams, // comma-separated string "1,2,3"
        created_by,
      } = req.body;

      const files = req.files as Express.Multer.File[];

      const parsedTeams = teams
        ? teams.split(",").map((t: string) => Number(t.trim()))
        : [];

      const payload = {
        vendor_id: vendorId,
        lead_id: leadId,
        account_id: Number(account_id),
        misc_type_id: Number(misc_type_id),
        problem_description,
        reorder_material_details,
        quantity: quantity ? Number(quantity) : undefined,
        cost: cost ? Number(cost) : undefined,
        supervisor_remark: supervisor_remark || undefined,
        expected_ready_date: expected_ready_date
          ? new Date(expected_ready_date)
          : undefined,
        is_resolved: is_resolved === "true" ? true : false,
        created_by: Number(created_by),
        teams: parsedTeams,
        files,
      };

      const result =
        await UnderInstallationStageService.createMiscellaneousService(payload);

      return res.status(201).json({
        success: true,
        message: "Miscellaneous entry created successfully",
        data: result,
      });
    } catch (err: any) {
      console.error("âŒ Error in createMiscellaneousEntry:", err.message);
      return res.status(500).json({
        success: false,
        error: err.message || "Something went wrong",
      });
    }
  }

  async getAllMiscellaneousEntries(req: Request, res: Response) {
    try {
      const vendorId = Number(req.params.vendorId);
      const leadId = Number(req.params.leadId);

      const result =
        await UnderInstallationStageService.getAllMiscellaneousService(
          vendorId,
          leadId
        );

      return res.status(200).json({
        success: true,
        data: result,
      });
    } catch (err: any) {
      console.error("âŒ Error in getAllMiscellaneousEntries:", err.message);
      return res.status(500).json({
        success: false,
        error: err.message || "Something went wrong",
      });
    }
  }

  static async createMiscellaneousService(payload: MiscPayload) {
    const {
      vendor_id,
      lead_id,
      account_id,
      misc_type_id,
      problem_description,
      reorder_material_details,
      quantity,
      cost,
      supervisor_remark,
      expected_ready_date,
      is_resolved,
      created_by,
      teams,
      files,
    } = payload;

    // -----------------------------------------------------
    // 1. Upload all files FIRST (outside transaction)
    // -----------------------------------------------------
    let uploadedDocs: {
      original_name: string;
      sys_name: string;
    }[] = [];

    if (files && files.length > 0) {
      for (const file of files) {
        const sysName =
          await uploadToWasabiUnderInstallationMiscellaneousDocuments(
            file.buffer,
            vendor_id,
            lead_id,
            file.originalname
          );

        uploadedDocs.push({
          original_name: file.originalname,
          sys_name: sysName,
        });
      }
    }

    // -----------------------------------------------------
    // 2. Now DB transaction
    // -----------------------------------------------------
    return await prisma.$transaction(async (tx) => {
      // Create Misc entry
      const misc = await tx.miscellaneousMaster.create({
        data: {
          vendor_id,
          lead_id,
          account_id,
          misc_type_id,
          problem_description,
          reorder_material_details,
          quantity,
          cost,
          supervisor_remark,
          expected_ready_date,
          is_resolved,
          created_by,
        },
      });

      // Insert teams
      if (teams.length > 0) {
        await tx.miscellaneousTeamMapping.createMany({
          data: teams.map((teamId) => ({
            miscellaneous_id: misc.id,
            team_id: teamId,
          })),
        });
      }

      // ðŸ”¹ Fetch document type (Type 24)
      const docType = await prisma.documentTypeMaster.findFirst({
        where: { vendor_id: vendor_id, tag: "Type 24" },
      });

      if (!docType)
        throw Object.assign(
          new Error(
            "Document type (Type 24 â€“ under-installation-miscellaneous-Documents) not found"
          ),
          { statusCode: 404 }
        );

      // Insert Documents â†’ LeadDocuments + MiscDocuments
      for (const doc of uploadedDocs) {
        const leadDoc = await tx.leadDocuments.create({
          data: {
            doc_og_name: doc.original_name,
            doc_sys_name: doc.sys_name,
            vendor_id,
            lead_id,
            created_by,
            doc_type_id: docType.id, // Type 24 â†’ under-installation-miscellaneous-Documents
          },
        });

        await tx.miscellaneousDocument.create({
          data: {
            vendor_id,
            miscellaneous_id: misc.id,
            document_id: leadDoc.id,
            created_by,
          },
        });
      }

      return misc;
    });
  }

  static async getAllMiscellaneousService(
    vendor_id: number,
    lead_id: number
  ){
    const miscList = await prisma.miscellaneousMaster.findMany({
      where: { vendor_id, lead_id },
      orderBy: { created_at: "desc" },
      include: {
        type: true,
        createdBy: { select: { id: true, user_name: true } },
        teams: {
          include: {
            team: true,
          },
        },
        documents: {
          include: {
            document: true,
          },
        },
      },
    });
  
    // âžœ Attach signed URLs for documents
    const finalResult = await Promise.all(
      miscList.map(async (m) => {
        const docs = await Promise.all(
          m.documents.map(async (docLink) => {
            const signed_url = await generateSignedUrl(docLink.document.doc_sys_name);
  
            return {
              document_id: docLink.document.id,
              original_name: docLink.document.doc_og_name,
              file_key: docLink.document.doc_sys_name,
              signed_url,
              uploaded_at: docLink.document.created_at,
            };
          })
        );
  
        return {
          id: m.id,
          vendor_id: m.vendor_id,
          lead_id: m.lead_id,
          account_id: m.account_id,
          type: {
            id: m.type.id,
            name: m.type.name,
          },
          problem_description: m.problem_description,
          reorder_material_details: m.reorder_material_details,
          quantity: m.quantity,
          cost: m.cost,
          supervisor_remark: m.supervisor_remark,
          expected_ready_date: m.expected_ready_date,
          is_resolved: m.is_resolved,
          resolved_at: m.resolved_at,
          created_by: m.created_by,
          created_at: m.created_at,
          created_user: m.createdBy,
          teams: m.teams.map((t) => ({
            team_id: t.team_id,
            team_name: t.team.name,
          })),
          documents: docs,
        };
      })
    );
  
    return finalResult;
  };